I"`'<p>In Clojure, and in functional languages in general, there are multiple ways to adapt functions to various types (in our case it will be animals). If we need to adapt function to various types, we usually use conditions (if, cond..), and if we want to add new behavior for another type, we need to touch part of code where types are distinguished.</p>

<p>I have a function</p>

<script src="https://gist.github.com/46947964f83e15e6a270.js"></script>

<p>Results</p>

<script src="https://gist.github.com/8917852c3dcf472e88fb.js"></script>

<script src="https://gist.github.com/1dc7aac1f416e9d342f3.js"></script>

<p>and I decided to find out something about Pumpkin and adopt him</p>

<script src="https://gist.github.com/5cd35c3b34f1b0cb1014.js"></script>

<p>I need to add a map for pumpkin, into map of animals and an ‘animal language’ into tell-me-about-animal function (this animal sound is located in this function because all cats have the same language, so it doesn’t make sense to write it with every new cat, or dog .. )</p>

<script src="https://gist.github.com/4bcda1e07eff41a1e9a2.js"></script>

<p>Result</p>

<script src="https://gist.github.com/d452da45dcae3f71a732.js"></script>

<h1 id="multimethods">Multimethods</h1>

<p>In this case, using multimethods makes our code more extensible, because when adding a new animal type, we don’t need to touch the <code class="language-plaintext highlighter-rouge">tell-me-about-animal</code> core function, which could be for example located in a library, and it would be difficult/impossible to modify it. So to add a new animal type, we just add a new case to our multimethod (defmethod).</p>

<script src="https://gist.github.com/a8a1aab71011a91a7f32.js"></script>

<p>Results</p>

<script src="https://gist.github.com/3ab30420559b9dec711c.js"></script>

<script src="https://gist.github.com/342bb6c1a4f9637e41f3.js"></script>

<p><mark> defmulti</mark> creates a new multimethod with dispatch function. Therefore we create multimethod with name <code class="language-plaintext highlighter-rouge">animal-sound</code> and dispatch function in this multimethod selects keyword <code class="language-plaintext highlighter-rouge">:species</code> from argument.</p>

<script src="https://gist.github.com/a4d41601172b0c7b4c0c.js"></script>

<p><mark>defmethod</mark> creates and installs a new method for mutimethod associated with dispatch value. <code class="language-plaintext highlighter-rouge">defmethod animal-sound</code> creates a new method for <code class="language-plaintext highlighter-rouge">(defmulti animal-sound (fn [my-animal] (:species my-animal))</code>.</p>

<p>We created three methods:</p>

<h4 id="first-method">First method</h4>

<script src="https://gist.github.com/43297e0e6b72898e9d98.js"></script>

<p>is called, if returned value from <code class="language-plaintext highlighter-rouge">defmulti animal-sound</code> dispatching function is <code class="language-plaintext highlighter-rouge">:cat</code></p>

<h4 id="second-method">Second method</h4>

<script src="https://gist.github.com/6d9719e15ffedf7f2cbf.js"></script>

<p>is called, if returned value from <code class="language-plaintext highlighter-rouge">defmulti animal-sound</code> dispatching function is <code class="language-plaintext highlighter-rouge">:dog</code></p>

<h3 id="third-method">Third method</h3>

<script src="https://gist.github.com/1c4761f70b60dd3022b0.js"></script>

<p>is called, if returned value doesn’t match any of the others methods.</p>

<p>example</p>

<p>if we call <code class="language-plaintext highlighter-rouge">(animal-sound {:name "Twiggi" :species :dog :home "house" :age 3})</code> the dispatch function returns value under the keyword <code class="language-plaintext highlighter-rouge">:species</code> , which is <code class="language-plaintext highlighter-rouge">:dog</code> , and the appropriate method is used. Which means returned value will be <code class="language-plaintext highlighter-rouge">"Woof"</code></p>

<script src="https://gist.github.com/9ce1d3597716ba311a2a.js"></script>

<p>Now I want to add Pumpkin.</p>

<p>It is pretty simple. I just need to add pumpkin into <code class="language-plaintext highlighter-rouge">my-animals</code> map and add new method for species <code class="language-plaintext highlighter-rouge">:pig</code>. With every new animal species you need to add only new method. You don’t need to dispatch only on keyword value as we do now, the dispatching logic can be really complicated if you wish (i.e we can dispatch on sum of some arguments, first letters from some string, e.t.c).</p>

<script src="https://gist.github.com/1236ce8c81fbbf0cd591.js"></script>

<p>Result</p>

<script src="https://gist.github.com/d452da45dcae3f71a732.js"></script>

<h1 id="protocols">Protocols</h1>

<p>Because protocols are faster than multimethods, we use protocols when they are sufficient. It is used, when you need to dispatch only on type. We still can use multimethods, when the dispatching logic gets more complicated. So in our example it’s better to use protocols, because we need to dispatch only on type.</p>

<p>Create protocol</p>

<script src="https://gist.github.com/05d7afaef6a4c0b787f1.js"></script>

<p>Defprotocol takes a name and optional docstring. Next there are the method signatures. Method signatures contain method name <code class="language-plaintext highlighter-rouge">(sound)</code> argument specification <code class="language-plaintext highlighter-rouge">([this])</code> and an optional docstring <code class="language-plaintext highlighter-rouge">("animal language")</code>. When we want to implement protocol in any way, we always need to implement all protocol methods.</p>

<p><mark> reify</mark> creates a unique anonymous type. It is useful when you need to create single implementation of protocol, which doesn’t have a named type.</p>

<script src="https://gist.github.com/e9bbb833a6a7ba9a7cf3.js"></script>

<p>we created one anonymous instance, which implements protocol <code class="language-plaintext highlighter-rouge">IAnimal</code> with all protocol methods.</p>

<p>On this instance <code class="language-plaintext highlighter-rouge">yeti</code> we can call all protocol methods.</p>

<p>Result</p>

<script src="https://gist.github.com/c1eb0c78b0f6edf5f60d.js"></script>

<p><mark> deftype</mark> creates a named type which implements a protocol.</p>

<script src="https://gist.github.com/e4521ed8bb8046877f3b.js"></script>

<p><code class="language-plaintext highlighter-rouge">deftype Goat</code> creates new type which can take arguments (in our example arguments field is empty, because we don’t use them) ,followed by protocol name which we want to implement <code class="language-plaintext highlighter-rouge">(IAnimal)</code> and implementation of all protocol methods.</p>

<p>i.e. <code class="language-plaintext highlighter-rouge">(sound [this] "Meh")</code> is protocol implementation for <code class="language-plaintext highlighter-rouge">IAnimal</code> method <code class="language-plaintext highlighter-rouge">(sound [this] "animal language")</code></p>

<p><code class="language-plaintext highlighter-rouge">(def Kozenka (Goat.))</code> constructs a new instance of type Goat.</p>

<p>Result</p>

<script src="https://gist.github.com/762b69eab48d1e3a67d0.js"></script>

<p>Now we can call method <code class="language-plaintext highlighter-rouge">sound</code> on instance <code class="language-plaintext highlighter-rouge">Kozenka</code></p>

<p><mark> defrecord</mark> creates a named type which implements protocol and additionaly behaves like map for any arguments passed to constructor (where map keys are argument names, and map values are actual arguments passed when calling a constructor)</p>

<script src="https://gist.github.com/f07bdba7c400a6871852.js"></script>

<p>We defined new record of type <code class="language-plaintext highlighter-rouge">Cat</code>, with arguments <code class="language-plaintext highlighter-rouge">name</code> <code class="language-plaintext highlighter-rouge">home</code> <code class="language-plaintext highlighter-rouge">age</code>. For this record we implemented <code class="language-plaintext highlighter-rouge">IAnimal</code> with all protocol methods.</p>

<p>Then we defined new instance of type cat assigned to <code class="language-plaintext highlighter-rouge">Siggi</code>, with arguments<code class="language-plaintext highlighter-rouge">"Siggy"</code> <code class="language-plaintext highlighter-rouge">"House"</code> <code class="language-plaintext highlighter-rouge">1</code></p>

<p>When we call <code class="language-plaintext highlighter-rouge">Siggi</code> , <code class="language-plaintext highlighter-rouge">"Siggi" "House" 1</code> are passed as values for keywords <code class="language-plaintext highlighter-rouge">name home age</code> as defined in <code class="language-plaintext highlighter-rouge">defrecord Cat</code>.</p>

<p>Now we can call all methods (sound, species) on instance <code class="language-plaintext highlighter-rouge">Siggi</code></p>

<p>Result</p>

<script src="https://gist.github.com/a33ebfe4104a7806f4bb.js"></script>

<script src="https://gist.github.com/d8df0573bf8ad0b3df18.js"></script>

<p>You can work with them like with maps. You can call assoc, dissoc, keys e.t.c on them.</p>

<script src="https://gist.github.com/2e5bd6c0d7f31e3e73e0.js"></script>

<h4 id="take-a-look-at-our-example-with-protocols">Take a look at our example with protocols</h4>

<script src="https://gist.github.com/b5e7864f16fcbf817e31.js"></script>

<p>Results</p>

<script src="https://gist.github.com/8917852c3dcf472e88fb.js"></script>

<script src="https://gist.github.com/1dc7aac1f416e9d342f3.js"></script>

<p>And now we add pumpkin</p>

<script src="https://gist.github.com/d92618bb44729c1bf430.js"></script>

<p>We just added pumpkin into my-animals map and created new defrecord for species pig.</p>

<p>Result</p>

<script src="https://gist.github.com/5c3f4cdf56bd921473d3.js"></script>

<p>The end :)</p>

:ET