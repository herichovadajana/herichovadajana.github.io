I"k(<p>This time Iâ€™m trying to understand protocols. To be honest, Iâ€™ve never heard about protocols till today, butÂ I wanted this knowlege, so I studied, and hereâ€™s the result ðŸ˜Š</p>

<h2 id="why-do-we-need-multimethods-and-protocols">Why do we need Multimethods and Protocols?</h2>

<p>In Clojure, and in functional languages in general, there are multiple ways to adapt functions to various types (in our case it will be animals). If we need to adapt function to various types, we usually use conditions (if, cond..), and if we want to add new behavior for another type, we need to touch part of code where types are distinguished.</p>

<p>I have a function</p>

<script src="https://gist.github.com/herichovadajana/46947964f83e15e6a270.js"></script>

<p>Results</p>

<script src="https://gist.github.com/herichovadajana/8917852c3dcf472e88fb.js"></script>

<script src="https://gist.github.com/herichovadajana/1dc7aac1f416e9d342f3.js"></script>

<p>and I decided to find out something about Pumpkin and adopt him</p>

<script src="https://gist.github.com/herichovadajana/5cd35c3b34f1b0cb1014.js"></script>

<p>I need to add a map for pumpkin, into map of animals and an â€˜animal languageâ€™ into tell-me-about-animal function (this animal sound is located in this function because all cats have the same language, so it doesnâ€™t make sense to write it with every new cat, or dog .. )</p>

<script src="https://gist.github.com/herichovadajana/4bcda1e07eff41a1e9a2.js"></script>

<p>Result</p>

<script src="https://gist.github.com/d452da45dcae3f71a732.js"></script>

<h1 id="multimethods">Multimethods</h1>

<p>In this case, using multimethods makes our code more extensible, because when adding new animal type, we donâ€™t need to touch the <code class="language-plaintext highlighter-rouge">tell-me-about-animal</code> core function, which could be for example located in a library, as such it would be difficult/impossible to modify it. To add a new animal type, we just need to add a new case to our multimethod (defmethod).</p>

<script src="https://gist.github.com/herichovadajana/a8a1aab71011a91a7f32.js"></script>

<p>Results</p>

<script src="https://gist.github.com/herichovadajana/3ab30420559b9dec711c.js"></script>

<script src="https://gist.github.com/herichovadajana/342bb6c1a4f9637e41f3.js"></script>

<p><mark style="background-color:#ddead1;"> defmulti</mark> creates a new multimethod with dispatch function. In our case we create multimethod with name <code class="language-plaintext highlighter-rouge">animal-sound</code> and dispatch function in this multimethod selects keyword <code class="language-plaintext highlighter-rouge">:species</code> from argument.</p>

<script src="https://gist.github.com/a4d41601172b0c7b4c0c.js"></script>

<p><mark style="background-color:#ddead1;"> Defmethod</mark> creates and installs new method for mutimethod associated with dispatch value. <code class="language-plaintext highlighter-rouge">defmethod animal-sound</code>creates new method for <code class="language-plaintext highlighter-rouge">(defmulti animal-sound (fn [my-animal] (:species my-animal))</code>.</p>

<p>We created three methods:</p>

<p>first method</p>

<script src="https://gist.github.com/herichovadajana/43297e0e6b72898e9d98.js"></script>

<p>is called when returned value from <mark style="background-color:#f2f2f2;"> defmulti animal-sound </mark> dispatching function is <mark style="background-color:#f2f2f2;"> :cat </mark></p>

<p>second method</p>

<script src="https://gist.github.com/herichovadajana/6d9719e15ffedf7f2cbf.js"></script>

<p>is called if when returned value does not match any of the others methods.</p>

<p>example</p>

<p>if we call <mark style="background-color:#f2f2f2;"> (animal-sound {:name "Twiggi" :species :dog :home "house" :age 3}) </mark> the dispatch function returns value under keyword <mark style="background-color:#f2f2f2;"> :species </mark>, which is <mark style="background-color:#f2f2f2;"> :dog </mark>, and the appropriate method is used. Which means returned value will be <mark style="background-color:#f2f2f2;"> "Woof" </mark></p>

<script src="https://gist.github.com/9ce1d3597716ba311a2a.js"></script>

<p>Now I want to add Pumpkin.</p>

<p>It is pretty simple. I just need to add pumpkin into <mark style="background-color:#f2f2f2;"> my-animals </mark> map and add new method for species <mark style="background-color:#f2f2f2;"> :pig </mark>. With every new animal species you need to add only new method. You donâ€™t need to dispatch only on keyword value as we do now, the dispatching logic can be really complicated if you wish (i.e we can dispatch on sum of some arguments, first letters from some string, e.t.c).</p>

<script src="https://gist.github.com/1236ce8c81fbbf0cd591.js"></script>

<p>Result</p>

<script src="https://gist.github.com/d452da45dcae3f71a732.js"></script>

<h1 id="protocols">Protocols</h1>

<p>Because protocols are faster than multimethods, we use protocols when they are sufficient. It is used, when you need to dispatch only on type. We still can use multimethods, when the dispatching logic gets more complicated. So in our example itâ€™s better to use protocols, because we need to dispatch only on type.</p>

<p>Create protocol</p>

<script src="https://gist.github.com/05d7afaef6a4c0b787f1.js"></script>

<p>Defprotocol takes a name and optional docstring. Next there are the method signatures. Method signatures contain method name <mark style="background-color:#f2f2f2;"> (sound) </mark> argument specification <mark style="background-color:#f2f2f2;"> ([this]) </mark> and an optional docstring <mark style="background-color:#f2f2f2;"> ("animal language") </mark>. When we want to implement protocol in any way, we always need to implement all protocol methods.</p>

<p><mark style="background-color:#ddead1;"> reify</mark> creates a unique anonymous type. It is useful when you need to create single implementation of protocol, which doesnâ€™t have a named type.</p>

<script src="https://gist.github.com/e9bbb833a6a7ba9a7cf3.js"></script>

<p>we created one anonymous instance, which implements protocol <mark style="background-color:#f2f2f2;"> IAnimal </mark> with all protocol methods.</p>

<p>On this instance <mark style="background-color:#f2f2f2;"> yeti </mark> we can call all protocol methods.</p>

<p>Result</p>

<script src="https://gist.github.com/c1eb0c78b0f6edf5f60d.js"></script>

<p><mark style="background-color:#ddead1;"> deftype</mark> creates a named type which implements a protocol.</p>

<script src="https://gist.github.com/e4521ed8bb8046877f3b.js"></script>

<p><mark style="background-color:#f2f2f2;"> deftype Goat </mark> creates new type which can take arguments (in our example arguments field is empty, because we donâ€™t use them) ,followed by protocol name which we want to implement <mark style="background-color:#f2f2f2;"> (IAnimal) </mark> and implementation of all protocol methods.</p>

<p>i.e.<mark style="background-color:#f2f2f2;"> (sound [this] "Meh") </mark> is protocol implementation for <mark style="background-color:#f2f2f2;"> IAnimal </mark> method <mark style="background-color:#f2f2f2;"> (sound [this] "animal language") </mark></p>

<p><mark style="background-color:#f2f2f2;"> (def Kozenka (Goat.)) </mark> constructs a new instance of type Goat.</p>

<p>Result</p>

<script src="https://gist.github.com/762b69eab48d1e3a67d0.js"></script>

<p>Now we can call method <mark style="background-color:#f2f2f2;"> sound </mark> on instance <mark style="background-color:#f2f2f2;"> Kozenka </mark></p>

<p><mark style="background-color:#ddead1;"> defrecord</mark> creates a named type which implements protocol and additionaly behaves like map for any arguments passed to constructor (where map keys are argument names, and map values are actual arguments passed when calling a constructor)</p>

<script src="https://gist.github.com/f07bdba7c400a6871852.js"></script>

<p>We defined new record of type <mark style="background-color:#f2f2f2;"> Cat </mark>, with arguments <mark style="background-color:#f2f2f2;"> name </mark> <mark style="background-color:#f2f2f2;"> home </mark> <mark style="background-color:#f2f2f2;"> age </mark>. For this record we implemented <mark style="background-color:#f2f2f2;"> IAnimal </mark> with all protocol methods.</p>

<p>Then we defined new instance of type cat assigned to <mark style="background-color:#f2f2f2;"> Siggi </mark>, with arguments <mark style="background-color:#f2f2f2;"> "Siggy" </mark> <mark style="background-color:#f2f2f2;"> "House" </mark> <mark style="background-color:#f2f2f2;"> 1 </mark></p>

<p>When we call <mark style="background-color:#f2f2f2;"> Siggi </mark> , arguments <mark style="background-color:#f2f2f2;"> "Siggi" "House" 1 </mark> are passed as values for keywords <mark style="background-color:#f2f2f2;"> name home age </mark> as defined in <mark style="background-color:#f2f2f2;"> defrecord Cat </mark>.</p>

<p>Now we can call all methods (sound, species) on instance <mark style="background-color:#f2f2f2;"> Siggi </mark></p>

<p>Result</p>

<script src="https://gist.github.com/a33ebfe4104a7806f4bb.js"></script>

<script src="https://gist.github.com/d8df0573bf8ad0b3df18.js"></script>

<p>You can work with them like with maps. You can call assoc, dissoc, keys e.t.c on them.</p>

<script src="https://gist.github.com/2e5bd6c0d7f31e3e73e0.js"></script>

<h4 id="take-a-look-at-our-example-with-protocols">Take a look at our example with protocols</h4>

<script src="https://gist.github.com/b5e7864f16fcbf817e31.js"></script>

<p>Results</p>

<script src="https://gist.github.com/8917852c3dcf472e88fb.js"></script>

<script src="https://gist.github.com/1dc7aac1f416e9d342f3.js"></script>

<p>And now we add pumpkin</p>

<script src="https://gist.github.com/d92618bb44729c1bf430.js"></script>

<p>We just added pumpkin into my-animals map and created new defrecord for species pig.</p>

<p>Result</p>

<script src="https://gist.github.com/5c3f4cdf56bd921473d3.js"></script>

<p>I hope this post helped you understand protocols and multimethods. It was not easy journey for me, but I hope I did it. If you see some incorrect informations or you want to tell something more, or ask someting, feel free to write a comment.</p>

<p>Some <code class="language-plaintext highlighter-rouge">deftype</code> here</p>
:ET